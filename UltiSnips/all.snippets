snippet unique
def unique(lis):
    prev = -1
    res = []
    for i in lis:
        if i != prev:
            res.append(i)
            prev = i
    return res
endsnippet

snippet template
import os
import sys
from io import BytesIO, IOBase


def main():
    $0






















# region fastio
# Credits
# # template credits to cheran-senthil's github Repo

BUFSIZE = 8192


class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = "x" in file.mode or "r" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b"\n") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)


class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode("ascii"))
        self.read = lambda: self.buffer.read().decode("ascii")
        self.readline = lambda: self.buffer.readline().decode("ascii")


sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip("\r\n")

# endregion

if __name__ == "__main__":
    main()
endsnippet

snippet Test
for _ in range(int(input())):
endsnippet

snippet listInput
$0 = list(map(int,input().split()))
endsnippet

snippet splitInput
$0 = map(int,input().split())
endsnippet

snippet binSearch
def binary_search(array):
    left, right = 0, len(array) - 1
    while left <= right:
        mid = left + (right - left) // 2
        if condition(mid):
            right = mid - 1
        else:
            left = mid + 1
    return left
endsnippet

snippet primeSeive
def primeSeive(n):
    prime = [True for i in range(n + 1)]
    primes = []
    p = 2
    while (p * p <= n):
        if (prime[p] == True):
            for i in range(p * 2, n + 1, p):
                prime[i] = False
        p += 1
    prime[0] = False
    prime[1] = False
    for p in range(n + 1):
        if prime[p]:
            primes.append(p)
    return primes
endsnippet

snippet isPrime
def isPrime(n):
    if n==1:
        return False
    i=2
    while(i*i<=n):
        if n%i==0:
            return False
        i+=1
    return True
endsnippet

snippet primeFactors
def primeFactors(n):
    dic = defaultdict(int)
    factors = []
    while n % 2 == 0:
        dic[2] += 1
        n = n // 2
    
    i = 3
    while i * i <= n:
        while n % i == 0:
            dic[i] += 1
            n = n // i
        i += 2
    
    if n > 2:
        dic[n] += 1
    return dic
endsnippet

snippet fenwick
class BIT:
    def __init__(self, lis, n):
        self.n = n
        self.array = [0]+lis
        for idx in range(1,n):
            idx2 = idx+(idx & -idx)
            if idx2 < n:
                self.array[idx2] += self.array[idx]
    
    def prefix_query(self,idx):
        idx+=1
        result = 0
        while idx>0:
            result += self.array[idx]
            idx -= (idx & -idx)
        return result
    
    def range_query(self, from_idx, to_idx):
        return self.prefix_query(to_idx) - self.prefix_query(from_idx-1)
    
    def update(self,idx,add):
        idx+=1
        while idx<=self.n:
            self.array[idx]+=add
            idx += idx & -idx
        
    def __str__(self):
        return ' '.join(map(str, self.array))
endsnippet

snippet graphClass
import sys
from collections import deque as queue
sys.setrecursionlimit(10 ** 6)
class Graph(object):

    def __init__(self):
        self.neighbours = {}
    
    def __repr__(self):
        s = ''
        for i in self.neighbours:
            s += str(i)+': '+' '.join(map(str,self.neighbours[i])) + '\n'
        return s
    
    def add_node(self, node):
        self.neighbours[node] = set()
    
    def add_edge(self, edge):
        u, v = edge
        self.neighbours[u].add(v)
        self.neighbours[v].add(u)
    
    def dfs(self, node):
        visited[node] = 1
        for child in self.neighbours[node]:
            if visited[child] == 0:
                self.dfs(child)
    
    def bfs(self, node):
        q = queue()
        visited[node] = 1
        q.append(node)
        while q:
            cur = q.popleft()
            for child in self.neighbours[cur]:
                if visited[child] == 0:
                    q.append(child)
                    visited[child] = 1

g = Graph()
n, e = map(int, input().split())
for i in range(n):
    g.add_node(i+1)
for i in range(e):
    x, y = map(int, input().split())
    g.add_edge((x, y))
visited = [0] * (n + 1)
endsnippet

snippet bootstrap
from types import GeneratorType
def bootstrap(f, stack=[]):
    def wrappedfunc(*args, **kwargs):
        if stack:
            return f(*args, **kwargs)
        else:
            to = f(*args, **kwargs)
            while True:
                if type(to) is GeneratorType:
                    stack.append(to)
                    to = next(to)
                else:
                    stack.pop()
                    if not stack:
                        break
                    to = stack[-1].send(to)
            return to
    return wrappedfunc
endsnippet

snippet binPow
def binPow(n, r):
    c = 1
    while r > 0:
        if r & 1:
            r -= 1
            c *= n
        r = r // 2
        n = n ** 2
    return c
endsnippet

snippet ceil
def ceil(a, b):
    return (a + b - 1) // b
endsnippet

snippet mergeSort
def mergesort(arr, n):
    temp_arr = [0] * n
    return _mergesort(arr, temp_arr, 0, n - 1)

def _mergesort(arr, temp, l, r):
    ans = 0
    if l < r:
        mid = (l + r) // 2
        ans += _mergesort(arr, temp, l, mid)
        ans += _mergesort(arr, temp, mid + 1, r)
        ans += merge(arr, temp, l, mid, r)
    return ans

def merge(arr, temp, l, mid, r):
    count = 0
    i = l
    j = mid + 1
    nxt = l
    while i <= mid and j <= r:
        if arr[i] <= arr[j]:
            temp[nxt] = arr[i]
            nxt += 1
            i += 1
        else:
            count += (mid - i + 1)
            temp[nxt] = arr[j]
            nxt += 1
            j += 1
    
    while i <= mid:
        temp[nxt] = arr[i]
        nxt += 1
        i += 1
    
    while j <= r:
        temp[nxt] = arr[j]
        nxt += 1
        j += 1
    
    arr[l:r+1] = temp[l:r+1][:]
    
    return count
endsnippet

snippet skeleton
#include<bits/stdc++.h>
using namespace std;
#define INT             long long
#define endl            "\n"
#define inpArr(vec)          for(auto &it:vec) cin>>it
#define outArr(vec)          for(auto &it:vec) cout<<it<<" ";cout<<endl;

void solve(){

	$0

}


int main(){
ios_base::sync_with_stdio(0);cin.tie(NULL);
int tt=1;
cin >> tt;
while(tt--){
	solve();
}

return 0;

}
endsnippet

snippet debugCpp
template<typename T>
int SIZE(T (&t)){
	return t.size();
}
template<typename T, size_t N>
int SIZE(T (&t)[N]){
	return N;
}
string to_string(char t){
	return "'" + string({t}) + "'";
}
string to_string(bool t){
	return t ? "true" : "false";
}
string to_string(const string &t, int x1=0, int x2=1e9){
	string ret = "";
	for(int i = min(x1,SIZE(t)), _i = min(x2,SIZE(t)-1); i <= _i; ++i){
		ret += t[i];
	}
	return '"' + ret + '"';
}
string to_string(const char* t){
	string ret(t);
	return to_string(ret);
}
template<size_t N>
string to_string(const bitset<N> &t, int x1=0, int x2=1e9){
	string ret = "";
	for(int i = min(x1,SIZE(t)); i <= min(x2,SIZE(t)-1); ++i){
		ret += t[i] + '0';
	}
	return to_string(ret);
}
template<typename T, typename... Coords>
string to_string(const T (&t), int x1=0, int x2=1e9, Coords... C);
template<typename T, typename S>
string to_string(const pair<T, S> &t){
	return "(" + to_string(t.first) + ", " + to_string(t.second) + ")";
}
template<typename T, typename... Coords>
string to_string(const T (&t), int x1, int x2, Coords... C){
	string ret = "[";
	x1 = min(x1, SIZE(t));
	auto e = begin(t);
	advance(e,x1);
	for(int i = x1, _i = min(x2,SIZE(t)-1); i <= _i; ++i){
		ret += to_string(*e, C...) + (i != _i ? ", " : "");
		e = next(e);
	}
	return ret + "]";
}
template<int Index, typename... Ts>
struct print_tuple{
	string operator() (const tuple<Ts...>& t) {
		string ret = print_tuple<Index - 1, Ts...>{}(t);
		ret += (Index ? ", " : "");
		return ret + to_string(get<Index>(t));
	}
};
template<typename... Ts>
struct print_tuple<0, Ts...> {
	string operator() (const tuple<Ts...>& t) {
		return to_string(get<0>(t));
	}
};
template<typename... Ts>
string to_string(const tuple<Ts...>& t) {
	const auto Size = tuple_size<tuple<Ts...>>::value;
	return print_tuple<Size - 1, Ts...>{}(t);
}
void dbgr(){;}
template<typename Heads, typename... Tails>
void dbgr(Heads H, Tails... T){
	cout << to_string(H) << " | ";
	dbgr(T...);
}
void dbgs(){;}
template<typename Heads, typename... Tails>
void dbgs(Heads H, Tails... T){
	cout << H << " ";
	dbgs(T...);
}

/*
formatted functions:
*/

/*
consider __VA_ARGS__ as a whole:
dbgv() prints values only
dbg() prints name and values
*/
#define dbgv(...) cout << to_string(__VA_ARGS__) << endl;
#define dbg(...) cout << "[" << #__VA_ARGS__ << "]: "; dbgv(__VA_ARGS__);
endsnippet
